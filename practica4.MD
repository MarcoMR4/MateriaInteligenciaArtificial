üîô [Volver](README.MD)

## Practica 4 Introducci√≥n a la inteligencia artificial Introspecci√≥n: Contar islas en una matriz.

### Introducci√≥n. 
El siguiente ensayo es el planteamiento de c√≥mo resolver un problema, que consiste en contar el n√∫mero de islas dentro de una matriz de elementos rectangulares o cuadrados, seg√∫n la perspectiva que se note. El objetivo del mismo es poner en pr√°ctica la autopercepci√≥n de mi mente para encontrar la metodolog√≠a para resolver este problema.
Es importante conocer la forma en que nuestra mente trabaja y como asociando diferentes conocimientos previos, podemos encontrar la forma m√°s √≥ptima de encontrar una soluci√≥n para poder implementar las diferentes t√©cnicas de la inteligencia artificial.

### Desarrollo 
#### Percepci√≥n y an√°lisis del problema. 
Lo primero que observamos en este problema es una matriz de 14 x 22 cuadros, que m√°s bien tienen formas rectangulares, dentro del cual la mayor√≠a de los cuadros son blancos y se tienen 6 islas conformadas por cuadros grises oscuro, ese es el color que marca la diferencia y del cual se tienen que contar los cuadros para las islas. 
Al pedirse resolver el problema de contar los cuadros de diferente color, que ser√≠an los que contiene cada isla se toman en cuenta dos m√©todos, uno iterativo y uno recursivo en forma de algoritmos. Tomando esto en cuenta podr√≠amos asignar un valor num√©rico a los elementos de color gris oscuro como un 1 y los de color blanco como un cero. 

#### M√©todo iterativo. 
En la parte iterativa se utilizar√≠a una funci√≥n que pueda recorrer la matriz en el sentido de las filas y en cada fila una columna, se puede pasar un color como referencia num√©rica, en el caso de querer contar los elementos de color gris oscuro solo se har√≠a referencia al n√∫mero 1. Al recorrer cada posici√≥n, si el cuadro es blanco la referencia ser√≠a un 0, por lo que un contador auxiliar que utilicemos podr√≠a regresar un valor de 0, referenciando que no encontramos nada. 
Teniendo como referencia el tama√±o de la matriz, esto me hace asociarlo con un ciclo iterativo como por ejemplo el ciclo for, en el que podr√≠amos recorrer fila y las columnas en otro for anidado. Sin embargo, para poder contar las islas que se tendr√≠an en la matriz, deber√≠a de haber varios elementos con valor 1 conectados de forma vertical u horizontal, en cualquiera de las dos formas. Si en un dado caso se encuentra un valor de 1, se deber√≠a activar una variable que indique que se est√°n contando los elementos dentro de una isla por lo que se deber√≠a de guardar la referencia de las columnas en las que se encuentran los elementos  1 en dicha fila y luego continuar en la siguiente fila en el momento que se dejen de encontrar elementos 1, lo que se me ocurre es que despu√©s se recorre la siguiente fila espec√≠ficamente en las columnas referenciadas para as√≠ ver si tambi√©n hay elementos con valor 1. Aunque si hay otros elementos consecutivos en la misma fila, entonces estos tambi√©n formar√≠an parte de la isla, este proceso se har√≠a hasta llegar a un momento en el que ya no haya elementos 1 consecutivos y se contar√≠a como una isla. Despu√©s se repetir√≠a el proceso principal para encontrar m√°s islas. 

#### Ejemplo iterativo: 
def contarElementosIterativo(matriz, fila, columna, color):
	if matriz[fila][columna] != color:
        		return 0
	contador = 0
	referencia = [(fila, columna)]
 	while referencia:
      		  f, c = referencia.pop()
if 0 <= f < len(matriz) and 0 <= c < len(matriz[0]) and matriz[f][c] == color:
            contador += 1
            matriz[f][c] = None  
            stack.append((f + 1, c))
            stack.append((f - 1, c))
            stack.append((f, c + 1))
            stack.append((f, c - 1))
    return contador
Donde el color a contar ser√≠a 1.

#### M√©todo recursivo. 
Para una forma recursiva el m√©todo ser√≠a similar en su declaraci√≥n pero tendr√≠a que mandarse a llamar dentro pero indicando las diferentes direcciones en las que podr√≠a moverse la posici√≥n en la que estemos, tomando en cuenta claro, que si estamos en la posici√≥n 0, no podemos ir a un n√∫mero negativo y el l√≠mite ser√≠a ya sea el ancho o el alto de la matriz, adem√°s si devolvemos un valor de 1 cuando vamos encontrando una isla cuando se sume el contador podemos usar como referencia la recursividad del m√©todo utilizado. 

#### Ejemplo recursivo: 
def contarElementosRecursivo(matriz, fila, columna, color):
if not (0 <= fila < len(matriz)) or not (0 <= columna < len(matriz[0])) or matriz[fila][columna] != color:
        		return 0
	contador = 1
	matriz[fila][columna] = None
contador += contarElementosRecursivo (matriz, fila + 1, columna, color)
    	contador += contarElementosRecursivo (matriz, fila - 1, columna, color)
    	contador += contarElementosRecursivo (matriz, fila, columna + 1, color)
    	contador += contarElementosRecursivo (matriz, fila, columna - 1, color)

### Conclusi√≥n 
En conclusi√≥n, vemos que el m√©todo recursivo parece ser m√°s √≥ptimo que el iterativo, aunque pueden adaptarse caracter√≠sticas del otro seg√∫n se necesite, en este caso creo que incluso solo con aplicar el segundo es suficiente, sobre todo por la naturaleza del problema, en donde la conexi√≥n de los elementos que conforman una isla puede ser tanto de forma horizontal como vertical. 
Lo que pude observar en este ejercicio, es que yo ten√≠a asociado los m√©todos que vimos en las primeras clases con los ejercicios que est√°bamos resolviendo para encontrar islas tambi√©n, creo que, entrando en contexto con la inteligencia artificial, estas caracter√≠sticas tambi√©n podr√≠an ser aprendidas y aprovechadas para resolver el problema. 



